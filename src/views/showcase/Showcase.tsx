import { useEffect, useRef } from "react"
import InfoBar from "../../components/InfoBar"
import StudioCanvas from "../../components/StudioCanvas"
import { useStudio } from "../../contexts/StudioContext"
import { useListenableObject } from "../../studio/listenableobject/ListenableObject"
import { useObjectUnderMouse } from "../../studio/selections/ObjectClickedHook"
import { ShowcaseLight } from "../../studio/showcase/ShowcaseLight"
import ShowcaseView from "../../studio/showcase/ShowcaseView"
import AnimatorGumballPropertiesBar from "../animator/components/AnimatorGumballPropertiesBar"
import ShowcaseEffects from "./components/ShowcaseEffects"
import ShowcaseSidebar from "./components/ShowcaseSidebar"
import ShowcaseViewBar from "./components/ShowcaseViewBar"
import { useShowcaseGumball } from "./logic/ShowcaseGumballHook"

const Showcase = () => {
  const { scene, lightGroup, itemsGroup, getSelectedProject, onPostFrameListeners, renderer, controls, getCamera } = useStudio()
  const project = getSelectedProject()

  const [allViews, setViews] = useListenableObject(project.showcaseProperties.views)
  const [view] = useListenableObject(project.showcaseProperties.selectedView)

  useObjectUnderMouse()
  useShowcaseGumball()

  //TODO: get three context and listen on orbit controls for a change, then update the view's camera position and target
  //Also, in the view add a listener to update the orbit controls when view#position/target changes 

  const hasCameraAlreadyUpdated = useRef(false)

  useEffect(() => {

    const updateSelectedLight = (light: ShowcaseLight | null, oldLight: ShowcaseLight | null) => {
      if (oldLight) {
        scene.remove(oldLight.cameraHelper)
      }
      if (light) {
        scene.add(light.cameraHelper)
      }
    }

    const updatePosition = (position = view.cameraPosition.value) => {
      if (hasCameraAlreadyUpdated.current) {
        return
      }
      const camera = getCamera()
      camera.position.set(position[0], position[1], position[2])
      controls.update()
    }
    const updateTarget = (target = view.cameraTarget.value) => {
      if (hasCameraAlreadyUpdated.current) {
        return
      }
      controls.target.set(target[0], target[1], target[2])
      controls.update()
    }

    const onControlsStart = () => view.undoRedoHandler.startBatchActions()
    const onControlsChange = () => {
      const camera = getCamera()
      hasCameraAlreadyUpdated.current = true
      view.cameraPosition.value = [camera.position.x, camera.position.y, camera.position.z]
      view.cameraTarget.value = [controls.target.x, controls.target.y, controls.target.z]
      hasCameraAlreadyUpdated.current = false
    }

    let moveTimeout: NodeJS.Timeout | null = null
    const onControlsEnd = () => {
      //We need to batch the movement of the camera, as stuff like scrolling is done at each individual mouse event
      if (moveTimeout !== null) {
        clearTimeout(moveTimeout)
      }
      moveTimeout = setTimeout(() => view.undoRedoHandler.endBatchActions("Camera moved"), 200)
    }

    controls.addEventListener('start', onControlsStart)
    controls.addEventListener('change', onControlsChange)
    controls.addEventListener('end', onControlsEnd)
    view.cameraPosition.addAndRunListener(updatePosition)
    view.cameraTarget.addAndRunListener(updateTarget)
    view.selectedLight.addAndRunListener(updateSelectedLight)
    return () => {
      controls.removeEventListener('start', onControlsStart)
      controls.removeEventListener('change', onControlsChange)
      controls.removeEventListener('end', onControlsEnd)
      view.cameraPosition.removeListener(updatePosition)
      view.cameraTarget.removeListener(updateTarget)
      view.selectedLight.removeListener(updateSelectedLight)
      if (view.selectedLight.value) {
        scene.remove(view.selectedLight.value.cameraHelper)
      }
    }


  }, [view, getCamera, controls, scene])

  useEffect(() => {
    scene.remove(lightGroup)
    scene.remove(itemsGroup)
    scene.add(project.showcaseProperties.group)
    renderer.shadowMap.enabled = true
    const onFrame = () => {
      view.renderForGumball()
    }
    onPostFrameListeners.add(onFrame)

    return () => {
      scene.add(lightGroup)
      scene.add(itemsGroup)
      scene.remove(project.showcaseProperties.group)
      renderer.shadowMap.enabled = false

      onPostFrameListeners.delete(onFrame)
    }
  }, [view, scene, lightGroup, itemsGroup, project, renderer, onPostFrameListeners])

  const newView = () => {
    const view = new ShowcaseView(project.showcaseProperties)
    setViews([...allViews, view])
  }

  return (
    <div className="h-full grid grid-areas-showcase"
      key={project.identifier}
      style={{
        //These would be generated by moving the panels around.
        //For now, we just hardcode them
        gridTemplateColumns: '300px auto 300px',
        gridTemplateRows: 'auto 130px 30px 28px'
      }}
    >
      <div className="grid-in-tabs border dark:border-black border-white">
        <ShowcaseViewBar
          all={allViews}
          selected={project.showcaseProperties.selectedView as any /** More annoying casting. TODO: look at fixing this */}
          createNew={newView}
        />
      </div>
      <div className="grid-in-effects border dark:border-black border-white"><ShowcaseEffects /></div>
      <div className="grid-in-canvas border dark:border-black border-white min-h-0"><ShowcaseCanvas width={1920} height={1080} /></div>
      <div className="grid-in-info border dark:border-black border-white"><InfoBar undoRedo={view.undoRedoHandler} /></div>
      <div className="grid-in-gumball border dark:border-black border-white"><AnimatorGumballPropertiesBar consumer={view} /></div>
      <div className="grid-in-sidebar border dark:border-black border-white"><ShowcaseSidebar /></div>
    </div>
  )
}

const ShowcaseCanvas = ({ height, width }: { height: number, width: number }) => {
  return (
    <div className="h-full w-full relative bg-black">
      <div className="max-h-full w-full absolute top-1/2 -translate-y-1/2" style={{ aspectRatio: `${width / height}` }}>
        <div className="h-full max-w-full absolute left-1/2 -translate-x-1/2" style={{ aspectRatio: `${width / height}` }}>
          <StudioCanvas />
        </div>
      </div>
    </div>
  )
}

export default Showcase;